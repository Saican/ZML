/*

    What: Z-xtensible Markup Language Parser Event Handler
    Who: Sarah Blackburn
    When: 05/02/22

*/


class ZMLHandler : EventHandler
{
    string ZMLVersion;

    // Contains the contents of each def lump, without whitespace
    array<FileStream> defStreams;
    // Counts how many files failed to parse
    int abortCount;
    // Checks the array to see if any streams have the same hash
    bool HaveStream(int h)
    {
        for (int i = 0; i < defStreams.Size(); i++)
        {
            if (defStreams[i].LumpHash == h)
                return true;
        }

        return false;
    }

    // Reads each def lump into the defStreams array - without hashing files this function would cause duplicates!
    void Generate_DefStreams(int l = 0)
    {
        do
        {
            string rl = Wads.ReadLump(Wads.FindLump("zmldefs", l));
            if (!HaveStream(FileStream.GetLumpHash(rl)))
                defStreams.Push(new("FileStream").Init(rl, l));
            else
                console.printf("\t\t\ciZML Warning! \ccNo big deal, but tried to read the same lump twice!");
            l++;
        } while ((l = Wads.FindLump("zmldefs", l)) != -1);
    }


    /*
        LTOKEN's represent part of the
        ZMLDEFS syntax.  They are produced
        by the lexing portion of the tag list
        generator.

    */
    enum LTOKEN
    {
        T_END = 0,
        T_MORE = 1, // This is the standard, "please read from the file stream, lexer" token.  It means there's not enough info to make other tokens..

        // Keywords
        T_KEY_TAG,
        T_KEY_ATTRIBUTE,

        // Special Characters - context establishing tokens
        T_SPECIALCHAR_DOUBLEQUOTE,
        T_SPECIALCHAR_COMMA,
        T_SPECIALCHAR_OPENBRACE,
        T_SPECIALCHAR_CLOSEBRACE,
        T_SPECIALCHAR_SEMICOLON,
        T_SPECIALCHAR_BACKSLASH,
        T_SPECIALCHAR_ASTERISK,

        // Context dependent words - this means it matters where in the parser we are when reading these tokens
        T_WORD_NAME,
        T_WORD_TYPE,

        // These are errors
        T_IDKWHAT = -1,
        T_IDKWHAT_OPENCOMMENT = -2,
        T_IDKWHAT_OOB_AT = -3,
        T_IDKWHAT_OOB_LEN = -4,
        T_IDKWHAT_EOF = -5,
        T_IDKWHAT_INVALIDCHAR = -6,
    };

    LTOKEN stringToToken(string e)
    {
        // Keywords
        if (e ~== "tag")
            return T_KEY_TAG;
        if (e ~== "attributes")
            return T_KEY_ATTRIBUTE;

        // Special Characters
        if (e ~== "\"")
            return T_SPECIALCHAR_DOUBLEQUOTE;
        if (e ~== ",")
            return T_SPECIALCHAR_COMMA;
        if (e ~== "{")
            return T_SPECIALCHAR_OPENBRACE;
        if (e ~== "}")
            return T_SPECIALCHAR_CLOSEBRACE;
        if (e ~== ";")
            return T_SPECIALCHAR_SEMICOLON;
        if (e ~== "/")
            return T_SPECIALCHAR_BACKSLASH;
        if (e ~== "*")
            return T_SPECIALCHAR_ASTERISK;
            
            return T_MORE;
    }

    LTOKEN stringToErrorCheck(string e)
    {
        if (e ~== "OOB_at")
            return T_IDKWHAT_OOB_AT;
        if (e ~== "OOB_len")
            return T_IDKWHAT_OOB_LEN;
        if (e ~== "EOF")
            return T_IDKWHAT_EOF;
        if (e ~== "OPENC")
            return T_IDKWHAT_OPENCOMMENT;
        if (e ~== "INVLDC")
            return T_IDKWHAT_INVALIDCHAR;
        else
            return T_IDKWHAT;
    }

    string errorToString()
    {
        switch (t)
        {
            case T_IDKWHAT_OOB_AT: return "OOB_AT";
            case T_IDKWHAT_OOB_LEN: return "OOB_LEN";
            case T_IDKWHAT_EOF: return "EOF";
            case T_IDKWHAT_OPENCOMMENT: return "OPENCOMMENT";
            case T_IDKWHAT_INVALIDCHAR: return "INVALIDCHAR";
            default:
            case T_IDKWHAT: return "IDKWHAT";
        }
    }



    /*
        If any part of the code can actually be called the Lexer, this is it.
        It's job is to do nothing but produce tokens or errors.

    */
    void Lexer_DefLumps(out string e, int len)
    {
        string pt;
        bool found;
        [pt, found] = file.PeekJob(reader, len);    // PeekJob calls PeekTo and checks Peek with PeekFound
        if (found) // If Peek did not error, format peek into raw token and send to tokenizer
        {
            e = string.Format("%s%s", e, pt);
            t = stringToToken(e);
        }
        else
            t = stringToErrorCheck(pt);
    }

    /*
        These bools establish context
    */
    bool bStartComment,
        bStartLineComment,
        bStartBlockComment;

    /*
        The file being processed, the line read head, and the token generated by the lexer
        - There are 2 read heads, the global "reader" and file.Line, which determines which
          line of the file is being read.
    */
    FileStream file;
    int reader;
    LTOKEN t;

    ZMLTag ztag;
    array<ZMLTag> taglist;

    // This is the actual lexer/parser loop
    void Parse_DefLumps()
    {
        // Loop through the defStreams array
        for (int i = 0; i < defStreams.Size(); i++)
        {
            file = defStreams[i];
            reader = 0;
            t = T_MORE;
            ztag = null;

            while (t > T_END)  // Signalling 0 will end the loop
            {
                // Raw untokenized string - this is made empty each loop
                string e = "";
                // Tokeninzing returns something no matter what, either get more string, or error, until it's not that
                while (t == T_MORE)
                    Lexer_DefLumps(e, 1);

                // Parsing is basically, the Lexer gave us a valid "t" value, so do something as a result
                switch (t)
                {
                    case T_KEY_TAG:
                        // We got a tag def, so we'll initialize the ztag here, and then let the lexer loop
                        if (!ztag)
                            ztag = new("ZMLTag").Init("zml_empty", "t_none");

                        console.printf("Hey we got a tag!");
                        t = -1;
                        break;
                    case T_KEY_ATTRIBUTE:
                        break;

                    case T_SPECIALCHAR_DOUBLEQUOTE:
                        break;
                    case T_SPECIALCHAR_COMMA:
                        break;
                    case T_SPECIALCHAR_OPENBRACE:
                        break;
                    case T_SPECIALCHAR_CLOSEBRACE:
                        break;
                    case T_SPECIALCHAR_SEMICOLON:
                        break;
                    case T_SPECIALCHAR_BACKSLASH:
                        // Have we encountered another backslash?
                        if (bStartComment)
                            bStartLineComment = true;
                        // This might be a comment, so peek the next char to make sure
                        else if (file.Peek(reader) ~== "/" || file.Peek(reader) ~== "*")
                            bStartComment = true;
                        else
                            t = stringToErrorCheck("INVLDC");

                        t = T_MORE;
                        break;
                    case T_SPECIALCHAR_ASTERISK:
                        // Have we encountered a backslash?
                        if (bStartComment)
                            bStartBlockComment = true;
                        else
                            t = stringToErrorCheck("INVLDC");

                        t = T_MORE;
                        break;
                }
            
                if (t > T_END) // Context should be established so do something about it.
                    Parse_DefLump_Context();
            }

            if (t < T_END)
                DefLump_ErrorOutput();
        }
    }

    void Parse_DefLump_Context()
    {
        // Block Comment
        if (bStartComment && bStartBlockComment)
        {
            int nextLine = file.GetEOB(reader, "*/");
            if (nextLine != -1)
                file.Line = nextLine;
            else
                t = stringToErrorCheck("OPENC");
        }
        // Line Comment
        else if (bStartComment && bStartLineComment)
        {
            if (file.Line + 1 < file.Lines())
            {
                reader = 0;
                file.Line++;
            }
            else
                t = 0;
        }
    }

    void DefLump_ErrorOutput()
    {
        switch (t)
        {
            default:
            case T_IDKWHAT:
                console.printf(string.Format("\t\t\cgZML ERROR! Code: \cx%s_(%d) \cg- Lump #\ci%d\cg, contains an unidentified error, starting at line # \cii:%d\cg(\cyf:%d\cg)!\n\t\t\tLine contents: \cc%s", 
                    errorToString(), t, file.LumpNumber, file.Line, file.Stream[file.Line].TrueLine, file.Stream[file.Line].FullLine()));
                break;
            case T_IDKWHAT_OPENCOMMENT:
                console.printf(string.Format("\t\t\cgZML ERROR! Code: \cx%s_(%d) \cg- Lump #\ci%d\cg, contains an unclosed block comment, starting at line # \cii:%d\cg(\cyf:%d\cg)!\n\t\t\tLine contents: \cc%s", 
                    errorToString(), t,  file.LumpNumber, file.Line, file.Stream[file.Line].TrueLine, file.Stream[file.Line].FullLine()));
                break;
            case T_IDKWHAT_OOB_AT:
                console.printf(string.Format("\t\t\cgZML ERROR! Code: \cx%s_(%d) \cg- Lump #\ci%d\cg, caused an out of bounds reader, starting at line # \cii:%d\cg(\cyf:%d\cg)!\n\t\t\tLine contents: \cc%s", 
                    errorToString(), t,  file.LumpNumber, file.Line, file.Stream[file.Line].TrueLine, file.Stream[file.Line].FullLine()));
                break;
            case T_IDKWHAT_OOB_LEN:
                console.printf(string.Format("\t\t\cgZML ERROR! Code: \cx%s_(%d) \cg- Lump #\ci%d\cg, caused an out of bounds read length, starting at lin e# \cii:%d\cg(\cyf:%d\cg)!\n\t\t\tLine contents: \cc%s", 
                    errorToString(), t,  file.LumpNumber, file.Line, file.Stream[file.Line].TrueLine, file.Stream[file.Line].FullLine()));
                break;
            case T_IDKWHAT_EOF:
                console.printf(string.Format("\t\t\cgZML ERROR! Code: \cx%s_(%d) \cg- Lump #\ci%d\cg, read attempt reached the end of the file without finding valid data! Last known valid data started at line # \cii:%d\cg(\cyf:%d\cg)!\n\t\t\tLine contents: \cc%s", 
                    errorToString(), t,  file.LumpNumber, file.Line, file.Stream[file.Line].TrueLine, file.Stream[file.Line].FullLine()));
                break;
        }

        abortCount++;
    }

    override void OnRegister()
    {
        // This mess creates the nice greeting ZML sends to the console.
        ZMLVersion = "0.1";
        string greeting = "Greetings! I am the Z-xtensible Markup Language Parser Event System, ";
        string vers = "version: ";
        int greetlen = string.Format("%s%s%s", greeting, vers, ZMLVersion).Length();
        string fullGreeting = string.Format("\n\n\cx%s\cc%s\cy%s\n\cx", greeting, vers, ZMLVersion);
        for (int i = 0; i < greetLen; i++)
            fullGreeting = string.Format("%s%s", fullGreeting, "-");
        console.printf(fullGreeting);

        // Initialize internals
        abortCount = 0;
        bStartComment = bStartLineComment = bStartBlockComment = false;

        // Ok, read ZMLDEFS lumps into file streams
        Generate_DefStreams();
        console.printf(string.Format("\t\t\cdZML successfully read \cy%d \cdtag definition lumps into file streams!\n\t\t\t\t\cc- This means the ZMLDEFS files are in a parse-able format, it does not mean they are valid.\n\n", defStreams.Size()));
        // Assuming that there are now file streams, try to make the tag lists
        Parse_DefLumps();
        // Well, no, something was wrong - it got handled but bitch and moan anyway
        if (abortCount > 0)
            console.printf(string.Format("\n\t\t\ciZML failed to parse \cg%d \citag definition lumps!\n\t\t\t\t\cc- This means ZML encountered a problem with the file%s and stopped trying to create usable data from %s. Reported errors need fixed.\n\n", abortCount, (abortCount > 1 ? "s" : ""), (abortCount > 1 ? "them" : "it")));
        // Nevermind, yay!  We win!
        else
            console.printf(string.format("\n\t\t\cyZML successfully parsed \cx%d \cyZMLDEFS lumps into \cx%d \cyZML tags!\n\n", defStreams.Size(), taglist.Size()));
    }

    enum ZMLINFO
    {
        CODE_HELP,
        CODE_ERROR_IDKWHAT,
        CODE_ERROR_OPENCOMMENT,
        CODE_ERROR_OOB_AT,
        CODE_ERROR_OOB_LEN,
        CODE_ERROR_EOF,

        CODE_BADADVICE,
    };

    ZMLINFO stringToInfoToken(string e)
    {
        if (e ~== "help")
            return CODE_HELP;
        if (e ~== "idkwhat")
            return CODE_ERROR_IDKWHAT;
        if (e ~== "opencomment")
            return CODE_ERROR_OPENCOMMENT;
        if (e ~== "oob_at")
            return CODE_ERROR_OOB_AT;
        if (e ~== "oob_len")
            return CODE_ERROR_OOB_LEN;
        if (e ~== "eof")
            return CODE_ERROR_EOF;

        return CODE_BADADVICE;
    }

    /*
        Users can query ZML for information on errors.
    
    */
    override void NetworkProcess(ConsoleEvent e)
    {

    }

    /* - END OF METHODS - */
}

